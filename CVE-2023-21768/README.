# CVE-2023-21768

* The vulnerable code is in `AfdNotifyRemoveIoCompletion` function

![Screenshot 2024-04-02 150059](https://hackmd.io/_uploads/BJFSoVtkR.png)

* The code doesn't validate `field_18` pointer and this may cause arbitrary write bug 

## Trigger the code

* It's called from `AfdNotifySock` function

![Screenshot 2024-04-02 150235](https://hackmd.io/_uploads/H1qnsEF10.png)

![Screenshot 2024-04-02 150308](https://hackmd.io/_uploads/r156sEKyC.png)

* But there's no direct call to `AfdNotifySock` but it's in `AfdImmediateCallDispatch` function table
* In `afd` there's `2` dispatch tables `AfdImmediateCallDispatch` and `AfdIrpCallDispatch`
* When we call `DeviceIoControl` the driver will call `AfdDispatchDeviceControl` to handle our request

![Screenshot 2024-04-02 150923](https://hackmd.io/_uploads/BkrBpVFJR.png)

![Screenshot 2024-04-02 150829](https://hackmd.io/_uploads/r19rpEtkA.png)

* It get the index from `AfdIoctlTable` from our control code and call the coresponding function in `AfdIrpCallDispatch` table

![Screenshot 2024-04-02 151139](https://hackmd.io/_uploads/r1uTT4Yy0.png)

* We see that `AfdNotifySock` is not in `AfdIrpCallDispatch` table but there're `AfdDispatchImmediateIrp` function in that and this function will be used to call function from `AfdImmediateCallDispatch` table
 
![Screenshot 2024-04-02 151349](https://hackmd.io/_uploads/rJ5HR4KJ0.png)

* So to trigger `AfdNotifySock` we need to calculate the index and get the `ioctl` code from `AfdIoctlTable`

![Screenshot 2024-04-02 151558](https://hackmd.io/_uploads/Syj6CVFJR.png)

![edited](https://hackmd.io/_uploads/Bys0krFkA.jpg)

* So now we have the `ioctl code` to trigger the bug
* In `Afd` driver, we don't need to call `CreateFile` to open a handle to driver. According to [this](https://lolcads.github.io/posts/2022/06/exploiting_cve_2021_43247/) the `socket` call will eventually call `NtCreateFile` to open a handle to `Afd`

> In this case “mswsock.dll” tries to open a HANDLE to AFD or the “Ancillary Function Driver for WinSock”.

* The code to trigger ` AfdNotifySock`
```cpp=
int main()
{
	WSADATA wsaData;
	int iResult;
	SOCKET s;


	iResult = WSAStartup(MAKEWORD(2, 2), &wsaData);
	if (iResult != 0) {
		printf("[-]WSAStartup failed: %d\n", iResult);
		return 1;
	}

	s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (s == INVALID_SOCKET)
	{
		puts("[-]Create socket failed");
		exit(-1);
	}

	DeviceIoControl((HANDLE)s, 0x12127, inBuf, 0x30, NULL, NULL, NULL, NULL);
```

* Set breakpoint in `WinDbg`

![Screenshot 2024-03-23 155003](https://hackmd.io/_uploads/B1C-zHYkA.png)

* Success!
* The function first check some field then call the vulnerable function
* The first thing to bypass is that

![Screenshot 2024-04-02 153402](https://hackmd.io/_uploads/B17zQrtyR.png)

* So the struct's size is `0x30`
* Next

![Screenshot 2024-04-02 153458](https://hackmd.io/_uploads/B1Qr7rYyA.png)

* To bypass this i set `counter = 1`, `field_18 != 0`, `field_10 != 0`

![Screenshot 2024-04-02 153848](https://hackmd.io/_uploads/H1c7EBFkC.png)

* Here the `handle` field must be a valid handle of `IoCompletionObjectType` so first i have to create a handle to that
* To create the handle i find that a function `NtCreateIoCompletion` and how to use it [here](https://www.exploit-db.com/exploits/42743)
* And finally we trigger the vulnerable function `AfdNotifyRemoveIoCompletion`

![Screenshot 2024-03-23 213925](https://hackmd.io/_uploads/rJwmHBKy0.png)

* However to reach the vulnerable code we still have to bypass a few codes

![Screenshot 2024-04-02 154441](https://hackmd.io/_uploads/HkSFBBF1R.png)

* `field_28` must not be `0`

![Screenshot 2024-04-02 154526](https://hackmd.io/_uploads/ryr3SSK1C.png)

* `field_10` must be a valid userspace address
* The last thing we have to do

![Screenshot 2024-04-02 154621](https://hackmd.io/_uploads/BJ9l8Ht1R.png)

* The `IoRemoveIoCompletion` function must be success
* To do that we just need to call `NtSetIoCompletion` before trigger the code and we will get arbitrary write
* The value we can write is the times we call `NtSetIoCompletion` but we only need write `0x1` to exploit
* `Yarden Shafir` had a post about use `I/O Ring` to get arbitrary read/write in kernel [here](https://windows-internals.com/one-i-o-ring-to-rule-them-all-a-full-read-write-exploit-primitive-on-windows-11/)
* So we just need to write `0x1` to `I/O Ring` object to `RegBuffersCount=0x100` and `RegBuffers=0x1000000`, build some entries and replace target's token with system's token

![Screenshot 2024-04-02 143138](https://hackmd.io/_uploads/B1EIvSYy0.png)
